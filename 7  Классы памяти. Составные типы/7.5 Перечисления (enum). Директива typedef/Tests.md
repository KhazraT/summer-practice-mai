# 7.5 Перечисления (enum). Директива typedef. Тесты

* **Подвиг 1.** Выберите все верные утверждения, касающиеся перечислимого типа языка Си.
  * (+) перечисления позволяют задавать числовые константы времени компиляции
  * (+) константы перечисления связаны с целыми числами и не имеют скрытого поведения, как например, директивы
  * (-) перечисления позволяют задавать числовые константы времени выполнения программы (не компиляции)
  * (+) константы перечисления можно использовать в метках case оператора switch
  * (-) константы перечисления нельзя использовать в метках case оператора switch

* **Подвиг 2.** Выберите все верные объявления перечислений.
  * (+) enum window_styles {border=2, caption=4, sizeable=8} style;
  * (+) enum {v2=2, v3=3, v4=4} vector_dim;
  * (+) enum {black=0, red=0xCC0000, green = 0x00CC00, blue=0x0000CC, white=255};
  * (+) enum sizes {width=1280, height=720};
  * (+) enum types {type_int, type_double, type_long};

* **Подвиг 3.** Выберите все верные утверждения, касающиеся следующего фрагмента программы:
```#include <stdio.h>```
```enum window_styles {border=2, caption=4, sizeable=8};```
```int main(void)```
```{```
```    enum window_styles style = 0;```
```    style = border | caption;```
```    return 0;```
```}```
  * (+) переменная style сначала инициализируется нулем, а затем ей присваивается десятичное значение 6
  * (-) переменная style сначала инициализируется нулем, а затем ей присваивается десятичное значение 5
  * (+) переменная style на уровне машинных кодов представляется и обрабатывается, как целочисленная переменная типа int
  * (+) переменную style можно использовать, как целочисленную переменную типа int (но делать так не рекомендуется)
  * (+) в программе объявлено перечисление с идентификатором window_styles
  * (+) в программе объявлена переменная style перечисляемого типа

* **Подвиг 6.** Выберите все верные утверждения, касающиеся директивы typedef
  * (+) директива typedef позволяет задавать новые имена существующим типам данных
  * (+) при помощи директивы typedef достигается лучшая переносимость текста программы с одной платформы на другую (пример, использование типа size_t)
  * (+) typedef обрабатывается компилятором, а не препроцессором, поэтому работает "более тонко" и корректно, чем обычные директивы препроцессора
  * (-) директива typedef обрабатывается текстовым препроцессором и небезопасна в использовании (как и все директивы препроцессора)
  * (+) директива typedef удобна при замене длинных названий типов на более короткие имена
  * (-) директива typedef позволяет создавать новые типы данных

* **Подвиг 7.** Выберите все верные варианты использования директивы typedef.
  * (+) typedef unsigned long ULONG;
  * (+) typedef enum menu_item {item_exit, item_c} MENU;
  * (+) typedef enum {type_int, type_double, type_long} TYPES;
  * (+) typedef char* P_STR;
  * (-) typedef double(*)(int, int) PTR_FUNC;
  * (-) typedef TYPES enum {type_int, type_double, type_long};
  * (+) typedef double (*PTR_FUNC)(int, int);
  * (-) typedef char[100] STR;
  * (-) typedef int long;

* **Подвиг 10 (на повторение).** Пусть имеется следующий фрагмент программы:
```double* p1 = (void *)128000, *p2 = (void *)128064;  // тип double 64 бит```
```int count = p2 - p1;```
Чему будет равно значение переменной count при выполнении этих двух строчек?
  * 8