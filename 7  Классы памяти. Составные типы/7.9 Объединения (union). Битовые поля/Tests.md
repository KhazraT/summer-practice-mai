# 7.9 Объединения (union). Битовые поля. Тесты

* **Подвиг 1.** Выберите все верные утверждения, касающиеся объединений.
  * (-) поля в объединении располагаются в памяти строго друг за другом
  * (-) объединения задаются согласно синтаксису: \[идентификатор] union {\[поля]};
  * (+) в программе на Си допустимо создавать указатели типа объединения
  * (+) поля в объединении располагаются с одного и того же адреса
  * (+) работа с полями объединений синтаксически осуществляется также, как и в структурах
  * (+) объединения задаются согласно синтаксису: union \[идентификатор] {\[поля]};

* **Подвиг 2.** Выберите все верные варианты объявления объединений.
  * (+) typedef union tag_var {char ch; int d; double vd; } VAR;
  * (+) union tag_var {char ch; int d; double vd; } var;
  * (-) union {char ch; int d; double vd; };
  * (+) typedef union {char ch; int d; double vd; } VAR;
  * (+) union {char ch; int d; double vd; } var;
  * (+) union tag_var {char ch; int d; double vd; };
  * (-) typedef union tag_var VAR {char ch; int d; double vd; };

* **Подвиг 3.** Выберите все верные утверждения, касающиеся следующего фрагмента программы:
```union tag_var {```
```    char ch;```
```    int d;```
```    double vd; ```
```};```
```int main(void)```
```{```
```    union tag_var var;```
```    var.ch = 'a';```
```    var.d = 10;```
```    var.vd = 0.5;```
```    return 0;```
```}```
  * (-) поле d переменной var хранит значение 10
  * (-) поле ch переменной var хранит символ 'a'
  * (+) поле vd переменной var хранит значение 0.5
  * (+) для чтения корректно записанного значения из переменной var нужно знать последнее поле, в которое осуществлялась запись

* **Подвиг 5.** Выберите все верные варианты присвоения значений переменной d типа DATA (на объединение):
```typedef union {```
```    int data_i;```
```    double data_d;```
```} DATA;```
```DATA d;```
  * (+) d.data_d = -0.01;
  * (+) d = (DATA){.data_d = 0.5};
  * (+) d = (DATA){.data_d = 0.5, .data_i = -5};
  * (-) d = (DATA)10;
  * (+) d.data_i = 12;
  * (+) d = (DATA){10};
  * (-) d = (DATA)0.74;

* **Подвиг 6.** Изучите следующую программу и отметьте все верные утверждения, связанные с ней:
```#include <stdio.h>```
```typedef enum {param_int=1, param_double=2} TYPE_PARAM;```
```typedef union {```
```    int data_i;```
```    double data_d;```
```} DATA;```
```DATA get_rect_sq(DATA a, DATA b, TYPE_PARAM type_params)```
```{```
```    return (type_params == param_int) ? (DATA){.data_i = a.data_i * b.data_i} :```
```                                        (DATA){.data_d = a.data_d * b.data_d};```
```}```
```int main(void)```
```{```
```    DATA sq_int = get_rect_sq((DATA){.data_i=10}, (DATA){.data_i=10}, param_int);```
```    DATA sq_double = get_rect_sq((DATA){.data_d=0.5}, (DATA){.data_d=1.5}, param_double);```
```    printf("rect_sq = %d\n", sq_int.data_i);```
```    printf("rect_sq = %f\n", sq_double.data_d);```
```    return 0;```
```}```
  * (-) фрагмент (DATA){.data_i=10} создает в памяти только целочисленную переменную со значением 10 и передает ее как объединение в параметр функции
  * (+) при возврате значения функции get_rect_sq "на лету" создает объект объединения и возвращает его (через копирование)
  * (+) благодаря использованию объединения DATA в программе не расходуется лишнего памяти при передаче аргументов функции get_rect_sq
  * (+) функция get_rect_sq позволяет вычислять площадь прямоугольника как с целочисленными данными, так и с вещественными
  * (+) фрагмент (DATA){.data_i=10} создает анонимный объект объединения и копирует его в параметр функции get_rect_sq

* **Подвиг 8.** Выберите все верные утверждения, касающиеся битовых полей.
  * (-) битовые поля определяются через структуру, каждое поле которой рекомендуется определять типом unsigned char
  * (+) после переменной через двоеточие указывается число бит, которое отводится под хранение данных в ней
  * (-) битовые поля определяются через объединение, каждое поле которой рекомендуется определять типом unsigned char
  * (+) общий размер всех битовых полей кратен одному байту (то есть, составляет целое число байт в памяти)
  * (+) битовые поля определяются через структуру, каждое поле которой рекомендуется определять типом unsigned int
  * (-) общий размер всех битовых полей в памяти устройства равен сумме бит, отведенных каждому полю

* **Подвиг 10 (на повторение).** Выберите все верные варианты объявления строк.
  * (+) char s_1[] = {'B', 'a', 'l', 'a', 'k', 'i', 'r', 'e', 'v', '\0'};
  * (-) char s_5[100] = {"Balakirev", 'S', 'e', 'r', 'g', 'e', 'i', '\0'};
  * (+) char s_3[] = "Balakirev";
  * (+) char s_6[100] = "Sergey " "Balakirev";
  * (+) char s_4[100] = "Balakirev";
  * (-) char s_7 = "Balakirev";
  * (+) char s_2[20] = {'B', 'a', 'l', 'a', 'k', 'i', 'r', 'e', 'v', '\0'};
  * (+) const char* s_8 = "Balakirev";